<!-- 3D Interactive Design | Built by Shivashankar -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sphere Packing Simulation</title>
    <style>
        /* Copyright (c) 2025 by Wakana Y.K. (https://codepen.io/wakana-k/pen/pvJGgpR) */
        @import url("https://fonts.googleapis.com/css2?family=Asap&display=swap");
        
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: "Asap", sans-serif;
            position: relative;
            width: 100vw;
            height: 100vh;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        canvas {
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            z-index: 1;
        }
        
        .btn_download {
            position: fixed;
            right: 0;
            bottom: 0;
            color: #ff6b6b;
            z-index: 10;
        }
        
        button.btn_stop {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 10;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        button.btn_stop:hover {
            background: linear-gradient(45deg, #ff5252, #e91e63);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        button.btn_stop:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 20px;
            font-weight: 600;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #info h3 {
            color: #ff6b6b;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading 3D Physics Simulation...</div>
    <div id="info" style="display: none;">
        <h3>3D Sphere Packing</h3>
        <p>Physics-based sphere simulation with Ammo.js</p>
        <p>Mouse: Rotate view | Scroll: Zoom</p>
    </div>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.177.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.177.0/examples/jsm/"
        }
    }
    </script>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/ammo.wasm.js"></script>

    <script type="module">
        /*!
        Sphere Packing 3D
        https://codepen.io/wakana-k/pen/pvJGgpR
        */
        console.clear();
        console.log('Starting 3D Sphere Packing Simulation...');

        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
        import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
        import "three/addons/exporters/PLYExporter.js";
        import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";

        // Global variables
        let camera, scene, renderer, controls, physics, terrainGeometry, environment;
        let terrainMesh, sphereInstances, loadingElement, infoElement;

        // Enhanced color palette with impressive colors
        const impressiveColors = [
            '#ff006e', // Electric Pink
            '#8338ec', // Electric Purple
            '#3a86ff', // Electric Blue
            '#06ffa5', // Electric Mint
            '#ffbe0b', // Electric Yellow
            '#fb5607', // Electric Orange
            '#ff4081', // Hot Pink
            '#7c4dff', // Deep Purple
            '#00e5ff', // Cyan
            '#76ff03', // Lime Green
            '#ff3d00', // Deep Orange
            '#e91e63', // Pink
            '#9c27b0', // Purple
            '#673ab7', // Deep Purple
            '#3f51b5', // Indigo
            '#2196f3', // Blue
            '#03a9f4', // Light Blue
            '#00bcd4', // Cyan
            '#009688', // Teal
            '#4caf50', // Green
            '#8bc34a', // Light Green
            '#cddc39', // Lime
            '#ffeb3b', // Yellow
            '#ffc107', // Amber
            '#ff9800', // Orange
            '#ff5722', // Deep Orange
            '#f44336', // Red
        ];

        // Neon glow colors
        const neonColors = [
            '#ff073a', // Neon Red
            '#39ff14', // Neon Green
            '#ff073a', // Neon Pink
            '#1b03a3', // Electric Blue
            '#ffff33', // Electric Yellow
            '#bc13fe', // Electric Purple
            '#ff6600', // Electric Orange
            '#00ffff', // Electric Cyan
            '#ff69b4', // Hot Pink
            '#adff2f', // Green Yellow
        ];

        // Utility function for impressive colors
        function getRandomColor() {
            const colorSets = [impressiveColors, neonColors];
            const selectedSet = colorSets[Math.floor(Math.random() * colorSets.length)];
            
            if (typeof chroma !== 'undefined') {
                try {
                    // Create vibrant colors using chroma.js
                    const baseColor = selectedSet[Math.floor(Math.random() * selectedSet.length)];
                    const color = chroma(baseColor)
                        .saturate(2)
                        .brighten(0.5)
                        .hex();
                    return color;
                } catch (e) {
                    console.warn('Chroma error, using fallback colors');
                }
            }
            
            // Fallback to impressive color palette
            return selectedSet[Math.floor(Math.random() * selectedSet.length)];
        }

        // Resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize the scene
        async function init() {
            try {
                loadingElement = document.getElementById('loading');
                infoElement = document.getElementById('info');

                // Initialize physics
                console.log('Initializing physics...');
                physics = await initAmmoPhysics();
                
                if (!physics) {
                    throw new Error('Failed to initialize physics engine');
                }

                // Create camera
                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 2);
                camera.lookAt(0, 0, 0);

                // Create scene with enhanced background
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a0a);

                // Enhanced lighting setup
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));

                // Add multiple directional lights for better color visibility
                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight1.position.set(1, 1, 1);
                scene.add(directionalLight1);

                const directionalLight2 = new THREE.DirectionalLight(0xff6b6b, 0.8);
                directionalLight2.position.set(-1, 1, -1);
                scene.add(directionalLight2);

                const directionalLight3 = new THREE.DirectionalLight(0x6b6bff, 0.6);
                directionalLight3.position.set(0, -1, 1);
                scene.add(directionalLight3);

                // Create renderer with enhanced settings
                renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                document.body.appendChild(renderer.domElement);

                // Create controls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.target.y = 0;
                controls.autoRotate = false;
                controls.enableDamping = true;
                controls.enablePan = false;
                controls.minDistance = 1;
                controls.minPolarAngle = 0;
                controls.maxPolarAngle = Math.PI / 2;
                controls.update();

                // Try to load HDR environment
                try {
                    const rgbeLoader = new RGBELoader();
                    environment = await new Promise((resolve, reject) => {
                        rgbeLoader.load(
                            "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/quarry_01_1k.hdr",
                            resolve,
                            undefined,
                            reject
                        );
                    });
                    environment.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = environment;
                    console.log('HDR environment loaded successfully');
                } catch (error) {
                    console.warn('Failed to load HDR environment:', error);
                    environment = null;
                }

                // Create enhanced sphere material
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    envMap: environment,
                    reflectivity: 0.9,
                    emissive: 0x000000,
                    specular: 0xffffff,
                    shininess: 150,
                    flatShading: false,
                    transparent: true,
                    opacity: 0.95
                });

                // Create terrain and spheres
                await createTerrain();
                createSpheres(sphereMaterial);

                // Hide loading, show info
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
                if (infoElement) {
                    infoElement.style.display = 'block';
                }

                // Start animation
                animate();

                // Add event listeners
                window.addEventListener('resize', onWindowResize);

                console.log('3D Sphere Packing simulation initialized successfully!');

            } catch (error) {
                console.error('Failed to initialize simulation:', error);
                if (loadingElement) {
                    loadingElement.innerHTML = 'Failed to load simulation. Please refresh the page.';
                }
            }
        }

        // Create terrain (fallback heart shape)
        async function createTerrain() {
            try {
                // Try to load the heart model
                const objLoader = new OBJLoader();
                const heartModel = await new Promise((resolve, reject) => {
                    objLoader.load(
                        "https://happy358.github.io/misc/model/Heart/Heart.obj",
                        resolve,
                        undefined,
                        reject
                    );
                });

                let geometry = heartModel.children[0].geometry;
                geometry = geometry.index ? geometry : BufferGeometryUtils.mergeVertices(geometry);
                geometry.computeVertexNormals();
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();

                terrainGeometry = geometry.clone();
                terrainGeometry.scale(0.1, 0.1, 0.11);
                geometry.center();
                geometry.computeVertexNormals();
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();
                terrainGeometry.name = "terrain";

                console.log('Heart model loaded successfully');

            } catch (error) {
                console.warn('Failed to load heart model, using fallback geometry:', error);
                
                // Create fallback heart-like geometry
                terrainGeometry = createHeartGeometry();
                terrainGeometry.name = "terrain";
            }

            // Create enhanced terrain material
            const terrainMaterial = new THREE.MeshLambertMaterial({
                color: new THREE.Color("#ff1744"),
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });

            // Create terrain mesh
            terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrainMesh.visible = false; // Hidden but used for physics
            terrainMesh.userData.physics = { mass: 0 };
            scene.add(terrainMesh);

            // Add to physics
            physics.addMesh(terrainMesh, 0);
        }

        // Create fallback heart geometry
        function createHeartGeometry() {
            const shape = new THREE.Shape();
            const x = 0, y = 0;

            shape.moveTo(x + 5, y + 5);
            shape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
            shape.bezierCurveTo(x - 6, y, x - 6, y + 3.5, x - 6, y + 3.5);
            shape.bezierCurveTo(x - 6, y + 5.5, x - 4, y + 7.7, x, y + 10);
            shape.bezierCurveTo(x + 4, y + 7.7, x + 6, y + 5.5, x + 6, y + 3.5);
            shape.bezierCurveTo(x + 6, y + 3.5, x + 6, y, x + 5, y + 5);

            const extrudeSettings = {
                depth: 2,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: 0.5,
                bevelThickness: 0.5
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.scale(0.02, 0.02, 0.02);
            geometry.center();
            
            return geometry;
        }

        // Create spheres with impressive colors
        function createSpheres(material) {
            const sphereGeometry = new THREE.IcosahedronGeometry(0.15, 1);
            const sphereCount = 80;
            
            sphereInstances = new THREE.InstancedMesh(sphereGeometry, material, sphereCount);
            sphereInstances.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            sphereInstances.userData.physics = { mass: 1 };

            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            // Position spheres randomly and set impressive colors
            for (let i = 0; i < sphereCount; i++) {
                matrix.setPosition(
                    THREE.MathUtils.randFloat(-0.7, 0.7),
                    THREE.MathUtils.randFloat(-0.4, 0.2),
                    THREE.MathUtils.randFloat(-0.2, 0.2)
                );
                sphereInstances.setMatrixAt(i, matrix);
                
                // Set impressive colors with enhanced saturation
                const impressiveColor = getRandomColor();
                color.set(impressiveColor);
                
                // Enhance color saturation and brightness
                color.multiplyScalar(1.2);
                sphereInstances.setColorAt(i, color);
            }

            scene.add(sphereInstances);
            physics.addMesh(sphereInstances, 1);

            // Create stop button
            createStopButton();
        }

        // Create stop button
        function createStopButton() {
            const stopButton = document.createElement("button");
            stopButton.className = "btn_stop";
            stopButton.innerText = "STOP Physics";
            document.body.appendChild(stopButton);

            function stopPhysics(event) {
                event.preventDefault();
                if (physics && typeof physics.destroy === 'function') {
                    physics.destroy();
                    console.log("Physics engine destroyed.");
                    stopButton.disabled = true;
                    stopButton.style.display = "none";
                }
            }

            stopButton.addEventListener("pointerdown", stopPhysics, { passive: true });
            stopButton.addEventListener("click", stopPhysics);
        }

        // Ammo.js Physics Engine
        async function initAmmoPhysics() {
            if (typeof Ammo === 'undefined') {
                console.error("AmmoPhysics: Couldn't find Ammo.js");
                return null;
            }

            try {
                const AmmoLib = await Ammo();
                console.log('Ammo.js initialized successfully');

                // Initialize physics world
                const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();
                const dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);
                const overlappingPairCache = new AmmoLib.btDbvtBroadphase();
                const solver = new AmmoLib.btSequentialImpulseConstraintSolver();
                const dynamicsWorld = new AmmoLib.btDiscreteDynamicsWorld(
                    dispatcher,
                    overlappingPairCache,
                    solver,
                    collisionConfiguration
                );

                // Set gravity
                dynamicsWorld.setGravity(new AmmoLib.btVector3(0, -9.8, 0));

                const transform = new AmmoLib.btTransform();
                let tempVector = new AmmoLib.btVector3(0, 0, 0);
                const rigidBodies = [];
                const meshMap = new WeakMap();

                // Create collision shape for geometry
                function createCollisionShape(geometry) {
                    const parameters = geometry.parameters;
                    let shape;

                    if (geometry.type === "BoxGeometry") {
                        const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;
                        const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;
                        const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;
                        shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));
                    } else if (geometry.type === "IcosahedronGeometry") {
                        const radius = parameters.radius !== undefined ? parameters.radius : 1;
                        shape = new AmmoLib.btSphereShape(radius);
                    } else if (geometry.name === "terrain") {
                        // Create triangle mesh for terrain
                        const vertices = geometry.attributes.position.array;
                        const indices = geometry.index.array;
                        const triangleMesh = new AmmoLib.btTriangleMesh();

                        for (let i = 0; i < indices.length; i += 3) {
                            const v1 = new AmmoLib.btVector3(
                                vertices[indices[i] * 3],
                                vertices[indices[i] * 3 + 1],
                                vertices[indices[i] * 3 + 2]
                            );
                            const v2 = new AmmoLib.btVector3(
                                vertices[indices[i + 1] * 3],
                                vertices[indices[i + 1] * 3 + 1],
                                vertices[indices[i + 1] * 3 + 2]
                            );
                            const v3 = new AmmoLib.btVector3(
                                vertices[indices[i + 2] * 3],
                                vertices[indices[i + 2] * 3 + 1],
                                vertices[indices[i + 2] * 3 + 2]
                            );
                            triangleMesh.addTriangle(v1, v2, v3);
                        }
                        shape = new AmmoLib.btBvhTriangleMeshShape(triangleMesh, true, true);
                    } else {
                        // Convex hull shape for complex geometries
                        const positionAttribute = geometry.getAttribute("position");
                        shape = new AmmoLib.btConvexHullShape();
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const x = positionAttribute.getX(i);
                            const y = positionAttribute.getY(i);
                            const z = positionAttribute.getZ(i);
                            const vertex = new AmmoLib.btVector3(x, y, z);
                            shape.addPoint(vertex, true);
                        }
                    }

                    shape.setMargin(0.015);
                    return shape;
                }

                // Add mesh to physics
                function addMesh(mesh, mass = 0) {
                    const shape = createCollisionShape(mesh.geometry);
                    if (!shape) return;

                    if (mesh.isInstancedMesh) {
                        const instancedMesh = mesh;
                        const instanceMatrices = instancedMesh.instanceMatrix.array;
                        const bodies = [];

                        for (let i = 0; i < instancedMesh.count; i++) {
                            const matrixOffset = i * 16;
                            const instanceTransform = new AmmoLib.btTransform();
                            instanceTransform.setFromOpenGLMatrix(
                                instanceMatrices.slice(matrixOffset, matrixOffset + 16)
                            );

                            const motionState = new AmmoLib.btDefaultMotionState(instanceTransform);
                            const localInertia = new AmmoLib.btVector3(0, 0, 0);
                            shape.calculateLocalInertia(mass, localInertia);

                            const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(
                                mass,
                                motionState,
                                shape,
                                localInertia
                            );
                            const body = new AmmoLib.btRigidBody(rbInfo);
                            body.setRestitution(0.3);
                            body.setFriction(0.8);

                            dynamicsWorld.addRigidBody(body);
                            bodies.push(body);
                        }

                        if (mass > 0) {
                            rigidBodies.push(instancedMesh);
                            meshMap.set(instancedMesh, bodies);
                        }
                    } else if (mesh.isMesh) {
                        const position = mesh.position;
                        const quaternion = mesh.quaternion;

                        transform.setIdentity();
                        transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
                        transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));

                        const motionState = new AmmoLib.btDefaultMotionState(transform);
                        const localInertia = new AmmoLib.btVector3(0, 0, 0);
                        shape.calculateLocalInertia(mass, localInertia);

                        const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                        const body = new AmmoLib.btRigidBody(rbInfo);
                        body.setRestitution(0.3);
                        body.setFriction(0.8);

                        dynamicsWorld.addRigidBody(body);

                        if (mass > 0) {
                            rigidBodies.push(mesh);
                            meshMap.set(mesh, body);
                        }
                    }
                }

                // Physics update loop
                let lastTime = 0;
                const updatePhysics = setInterval(() => {
                    const time = performance.now();
                    if (lastTime > 0) {
                        const deltaTime = (time - lastTime) / 1000;
                        dynamicsWorld.stepSimulation(deltaTime, 10);

                        // Update mesh positions
                        for (let i = 0; i < rigidBodies.length; i++) {
                            const mesh = rigidBodies[i];
                            
                            if (mesh.isInstancedMesh) {
                                const instanceMatrices = mesh.instanceMatrix.array;
                                const bodies = meshMap.get(mesh);

                                for (let j = 0; j < bodies.length; j++) {
                                    bodies[j].getMotionState().getWorldTransform(transform);
                                    const origin = transform.getOrigin();
                                    const rotation = transform.getRotation();

                                    // Reset if sphere falls too far
                                    if (origin.y() < -3 || origin.y() > 3) {
                                        tempVector.setValue(
                                            THREE.MathUtils.randFloat(-0.5, 0.5),
                                            THREE.MathUtils.randFloat(0, 1),
                                            THREE.MathUtils.randFloat(-0.5, 0.5)
                                        );
                                        transform.setIdentity();
                                        transform.setOrigin(tempVector);
                                        bodies[j].setWorldTransform(transform);
                                        bodies[j].setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));
                                        bodies[j].setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));
                                        bodies[j].clearForces();
                                    }

                                    // Update instance matrix
                                    const matrixOffset = j * 16;
                                    const matrix = new THREE.Matrix4();
                                    matrix.makeRotationFromQuaternion(
                                        new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w())
                                    );
                                    matrix.setPosition(origin.x(), origin.y(), origin.z());
                                    matrix.toArray(instanceMatrices, matrixOffset);
                                }

                                mesh.instanceMatrix.needsUpdate = true;
                                mesh.computeBoundingSphere();
                            } else if (mesh.isMesh) {
                                const body = meshMap.get(mesh);
                                body.getMotionState().getWorldTransform(transform);
                                const origin = transform.getOrigin();
                                const rotation = transform.getRotation();
                                
                                mesh.position.set(origin.x(), origin.y(), origin.z());
                                mesh.quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w());
                            }
                        }
                    }
                    lastTime = time;
                }, 1000 / 60);

                return {
                    addMesh: addMesh,
                    destroy: function() {
                        clearInterval(updatePhysics);
                        
                        // Clean up physics objects
                        for (const mesh of rigidBodies) {
                            const bodies = meshMap.get(mesh);
                            if (Array.isArray(bodies)) {
                                for (const body of bodies) {
                                    dynamicsWorld.removeRigidBody(body);
                                    AmmoLib.destroy(body);
                                }
                            } else {
                                dynamicsWorld.removeRigidBody(bodies);
                                AmmoLib.destroy(bodies);
                            }
                            meshMap.delete(mesh);
                        }

                        rigidBodies.length = 0;
                        AmmoLib.destroy(dynamicsWorld);
                        AmmoLib.destroy(solver);
                        AmmoLib.destroy(overlappingPairCache);
                        AmmoLib.destroy(dispatcher);
                        AmmoLib.destroy(collisionConfiguration);
                        AmmoLib.destroy(tempVector);
                        AmmoLib.destroy(transform);
                    }
                };

            } catch (error) {
                console.error('Failed to initialize Ammo.js:', error);
                return null;
            }
        }

        // Start the simulation
        init();
    </script>
</body>
</html>
